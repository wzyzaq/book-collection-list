/**
 * tdesign v1.12.0
 * (c) 2025 tdesign
 * @license MIT
 */

import { _ as _defineProperty } from '../_chunks/dep-daac9b4e.js';
import { _ as _slicedToArray } from '../_chunks/dep-17424654.js';
import { useState, useRef, useEffect } from 'react';
import classNames from 'classnames';
import { isString, isNumber, isUndefined } from 'lodash-es';
import { c as compareNumber, i as isInputNumber, l as largeNumberAdd, a as largeNumberSubtract, f as formatENumber, b as largeNumberToFixed } from '../_chunks/dep-3e196638.js';
import '../_chunks/dep-4d98bbe1.js';
import { l as log } from '../_chunks/dep-abe679d5.js';
import useConfig from '../hooks/useConfig.js';
import useControlled from '../hooks/useControlled.js';
import useCommonClassName from '../hooks/useCommonClassName.js';
import '../_chunks/dep-2b61bedd.js';
import '../_chunks/dep-73b0b578.js';
import '../config-provider/ConfigContext.js';
import '../locale/zh_CN.js';
import '../_chunks/dep-34028257.js';
import 'dayjs';
import '../_chunks/dep-55f7c5cf.js';
import '../_util/noop.js';

function canAddNumber(num, max) {
  var largeNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!num && num !== 0) return true;
  if (largeNumber && isString(num)) {
    return compareNumber(num, max, largeNumber) < 0;
  }
  return num < max;
}
function canReduceNumber(num, min) {
  var largeNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!num && num !== 0) return true;
  if (largeNumber && isString(num)) {
    return compareNumber(num, min, largeNumber) > 0;
  }
  return num > min;
}
function putInRangeNumber(val, params) {
  if (val === "") return void 0;
  var max = params.max,
    min = params.min,
    lastValue = params.lastValue,
    largeNumber = params.largeNumber;
  if (!isInputNumber(val)) return lastValue;
  if (largeNumber && (isString(max) || max === Infinity) && (isString(min) || min === -Infinity)) {
    if (compareNumber(max, val, largeNumber) < 0) return max;
    if (compareNumber(min, val, largeNumber) > 0) return min;
    return val;
  }
  return Math.max(Number(min), Math.min(Number(max), Number(val)));
}
function positiveAdd(num1, num2) {
  var _num1$toString$split$, _num2$toString$split$;
  if (!num1 || !num2) return (num1 || 0) + (num2 || 0);
  var r1 = ((_num1$toString$split$ = num1.toString().split(".")[1]) === null || _num1$toString$split$ === void 0 ? void 0 : _num1$toString$split$.length) || 0;
  var r2 = ((_num2$toString$split$ = num2.toString().split(".")[1]) === null || _num2$toString$split$ === void 0 ? void 0 : _num2$toString$split$.length) || 0;
  if (!r1 && !r2) return num1 + num2;
  var newNumber1 = num1;
  var newNumber2 = num2;
  var diff = Math.abs(r1 - r2);
  var digit = Math.pow(10, Math.max(r1, r2));
  if (diff > 0) {
    var cm = Math.pow(10, diff);
    if (r1 > r2) {
      newNumber1 = Number(num1.toString().replace(".", ""));
      newNumber2 = Number(num2.toString().replace(".", "")) * cm;
    } else {
      newNumber1 = Number(num1.toString().replace(".", "")) * cm;
      newNumber2 = Number(num2.toString().replace(".", ""));
    }
  } else {
    newNumber1 = Number(num1.toString().replace(".", ""));
    newNumber2 = Number(num2.toString().replace(".", ""));
  }
  return (newNumber1 + newNumber2) / digit;
}
function positiveSubtract(num1, num2) {
  var _num1$toString$split$2, _num2$toString$split$2;
  if (!num1 || !num2) return (num1 || 0) - (num2 || 0);
  var r1 = ((_num1$toString$split$2 = num1.toString().split(".")[1]) === null || _num1$toString$split$2 === void 0 ? void 0 : _num1$toString$split$2.length) || 0;
  var r2 = ((_num2$toString$split$2 = num2.toString().split(".")[1]) === null || _num2$toString$split$2 === void 0 ? void 0 : _num2$toString$split$2.length) || 0;
  var digit = Math.pow(10, Math.max(r1, r2));
  var n = r1 >= r2 ? r1 : r2;
  return Number(((num1 * digit - num2 * digit) / digit).toFixed(n));
}
function add(num1, num2) {
  if (num1 < 0 && num2 > 0) return positiveSubtract(num2, Math.abs(num1));
  if (num1 < 0 && num2 < 0) return positiveAdd(Math.abs(num1), Math.abs(num2)) * -1;
  if (num1 > 0 && num2 < 0) return positiveSubtract(num1, Math.abs(num2));
  return positiveAdd(num1, num2);
}
function subtract(num1, num2) {
  if (num1 < 0 && num2 > 0) return positiveAdd(Math.abs(num1), num2) * -1;
  if (num1 < 0 && num2 < 0) return positiveSubtract(Math.abs(num2), Math.abs(num1));
  if (num1 > 0 && num2 < 0) return positiveAdd(num1, Math.abs(num2));
  return positiveSubtract(num1, num2);
}
function getStepValue(p) {
  var op = p.op,
    step = p.step,
    lastValue = p.lastValue,
    max = p.max,
    min = p.min,
    largeNumber = p.largeNumber;
  if (Number(step) <= 0) {
    log.error("InputNumber", "step must be larger than 0.");
    return lastValue;
  }
  var tStep = isNumber(step) ? String(step) : step;
  var newVal;
  if (op === "add") {
    if (largeNumber && isString(lastValue)) {
      newVal = largeNumberAdd(String(lastValue), String(tStep));
    } else {
      newVal = add(Number(lastValue || 0), Number(step));
    }
  } else if (op === "reduce") {
    if (largeNumber && isString(lastValue)) {
      newVal = largeNumberSubtract(String(lastValue), String(tStep));
    } else {
      newVal = subtract(Number(lastValue || 0), Number(step));
    }
  }
  if (isUndefined(lastValue)) {
    newVal = putInRangeNumber(newVal, {
      max: max,
      min: min,
      lastValue: lastValue,
      largeNumber: largeNumber
    });
  }
  return largeNumber ? newVal : Number(newVal);
}
function getMaxOrMinValidateResult(p) {
  var largeNumber = p.largeNumber,
    value = p.value,
    max = p.max,
    min = p.min;
  if (isUndefined(value) || isUndefined(largeNumber)) return void 0;
  if (largeNumber && isNumber(value)) {
    log.warn("InputNumber", "largeNumber value must be a string.");
  }
  var error;
  if (compareNumber(value, max, largeNumber) > 0) {
    error = "exceed-maximum";
  } else if (compareNumber(value, min, largeNumber) < 0) {
    error = "below-minimum";
  } else {
    error = void 0;
  }
  return error;
}
var specialCode$1 = ["-", ".", "e", "E", "+"];
function canInputNumber(number, largeNumber) {
  var _number$match, _number$match2;
  if (["", null, void 0].includes(number)) return true;
  if (number.slice(0, 2) === "00") return false;
  if (number.match(/\s/g)) return false;
  if (((_number$match = number.match(/\./g)) === null || _number$match === void 0 ? void 0 : _number$match.length) > 1) return false;
  if (((_number$match2 = number.match(/e/g)) === null || _number$match2 === void 0 ? void 0 : _number$match2.length) > 1) return false;
  var tmpNumber = number.slice(1);
  var tmpMatched = tmpNumber.match(/(\+|-)/g);
  if (tmpMatched && (!/e(\+|-)/i.test(tmpNumber) || tmpMatched.length > 1)) return false;
  var isNumber2 = largeNumber && isInputNumber(number) || !Number.isNaN(Number(number));
  if (!isNumber2 && !specialCode$1.includes(number.slice(-1))) return false;
  if (/e/i.test(number) && (!/\de/i.test(number) || /e\./.test(number))) return false;
  return true;
}
function canSetValue(number, lastNumber) {
  return parseFloat(number) !== lastNumber && !Number.isNaN(Number(number));
}
function formatUnCompleteNumber(number) {
  var extra = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  if (["", null, void 0].includes(number) || !/\d+/.test(number)) return void 0;
  var decimalPlaces = extra.decimalPlaces,
    largeNumber = extra.largeNumber,
    isToFixed = extra.isToFixed;
  var newNumber = number.replace(/[.|+|\-|e]$/, "");
  if (largeNumber) {
    newNumber = formatENumber(newNumber);
  }
  if (decimalPlaces !== void 0) {
    newNumber = largeNumberToFixed(newNumber, decimalPlaces, largeNumber);
  }
  if (largeNumber) return newNumber;
  return isToFixed ? newNumber : parseFloat(newNumber);
}
function formatThousandths(number) {
  var thousandthsRegExp = /^[-+]?\d{1,3}(,\d{3})*(\.(\d*))?$/;
  if (thousandthsRegExp.test(number)) return number.replace(/,/g, "");
  return number;
}

var specialCode = ["-", ".", "e", "E"];
function useInputNumber(props) {
  var _useCommonClassName = useCommonClassName(),
    SIZE = _useCommonClassName.SIZE,
    STATUS = _useCommonClassName.STATUS;
  var _useConfig = useConfig(),
    classPrefix = _useConfig.classPrefix;
  var _useControlled = useControlled(props, "value", props.onChange),
    _useControlled2 = _slicedToArray(_useControlled, 2),
    tValue = _useControlled2[0],
    onChange = _useControlled2[1];
  var _useState = useState(""),
    _useState2 = _slicedToArray(_useState, 2),
    userInput = _useState2[0],
    setUserInput = _useState2[1];
  var _useState3 = useState(),
    _useState4 = _slicedToArray(_useState3, 2),
    isError = _useState4[0],
    setIsError = _useState4[1];
  var inputRef = useRef(null);
  var max = props.max,
    min = props.min,
    largeNumber = props.largeNumber,
    decimalPlaces = props.decimalPlaces,
    allowInputOverLimit = props.allowInputOverLimit,
    onValidate = props.onValidate;
  var disabledReduce = props.disabled || !canReduceNumber(tValue, props.min, props.largeNumber);
  var disabledAdd = props.disabled || !canAddNumber(tValue, props.max, props.largeNumber);
  var wrapClasses = classNames("".concat(classPrefix, "-input-number"), SIZE[props.size], _defineProperty(_defineProperty(_defineProperty(_defineProperty({}, STATUS.disabled, props.disabled), "".concat(classPrefix, "-is-controls-right"), props.theme === "column"), "".concat(classPrefix, "-input-number--").concat(props.theme), props.theme), "".concat(classPrefix, "-input-number--auto-width"), props.autoWidth));
  var reduceClasses = classNames("".concat(classPrefix, "-input-number__decrease"), _defineProperty({}, STATUS.disabled, disabledReduce));
  var addClasses = classNames("".concat(classPrefix, "-input-number__increase"), _defineProperty({}, STATUS.disabled, disabledAdd));
  var getUserInput = function getUserInput(value) {
    var _inputRef$current$cur, _inputRef$current$cur2;
    if (!value && value !== 0) return "";
    var inputStr = value || value === 0 ? String(value) : "";
    if (!((_inputRef$current$cur = (_inputRef$current$cur2 = inputRef.current.currentElement).contains) !== null && _inputRef$current$cur !== void 0 && _inputRef$current$cur.call(_inputRef$current$cur2, document.activeElement))) {
      var num = formatUnCompleteNumber(inputStr, {
        decimalPlaces: decimalPlaces,
        largeNumber: largeNumber,
        isToFixed: true
      });
      inputStr = num || num === 0 ? String(num) : "";
      if (props.format) {
        inputStr = String(props.format(value, {
          fixedNumber: inputStr
        }));
      }
    }
    return inputStr;
  };
  useEffect(function () {
    var inputValue = [void 0, null].includes(tValue) ? "" : String(tValue);
    if (!largeNumber && !Number.isNaN(userInput)) {
      if (parseFloat(userInput) !== tValue) {
        setUserInput(getUserInput(inputValue));
      }
      var fixedNumber = Number(largeNumberToFixed(inputValue, decimalPlaces, largeNumber));
      if (decimalPlaces !== void 0 && ![void 0, null].includes(tValue) && Number(fixedNumber) !== Number(tValue)) {
        onChange(fixedNumber, {
          type: "props",
          e: void 0
        });
      }
    }
    if (largeNumber) {
      var tmpUserInput = getUserInput(inputValue);
      setUserInput(tmpUserInput);
      if (decimalPlaces !== void 0 && largeNumberToFixed(inputValue, decimalPlaces, largeNumber) !== tValue) {
        onChange(tmpUserInput, {
          type: "props",
          e: void 0
        });
      }
    }
  }, [tValue]);
  useEffect(function () {
    if ([void 0, "", null].includes(tValue)) return;
    var error = getMaxOrMinValidateResult({
      value: tValue,
      max: max,
      min: min,
      largeNumber: largeNumber
    });
    setIsError(error);
    onValidate === null || onValidate === void 0 || onValidate({
      error: error
    });
  }, [tValue, max, min, largeNumber, onValidate]);
  var handleStepValue = function handleStepValue(op) {
    var newValue = getStepValue({
      op: op,
      step: props.step,
      max: props.max,
      min: props.min,
      lastValue: tValue,
      largeNumber: props.largeNumber
    });
    var largeNumber2 = props.largeNumber,
      max2 = props.max,
      min2 = props.min;
    var overLimit = getMaxOrMinValidateResult({
      value: newValue,
      largeNumber: largeNumber2,
      max: max2,
      min: min2
    });
    return {
      overLimit: overLimit,
      newValue: newValue
    };
  };
  var handleReduce = function handleReduce(e) {
    if (disabledReduce || props.readonly) return;
    var r = handleStepValue("reduce");
    if (r.overLimit && !allowInputOverLimit) return;
    onChange(r.newValue, {
      type: "reduce",
      e: e
    });
  };
  var handleAdd = function handleAdd(e) {
    if (disabledAdd || props.readonly) return;
    var r = handleStepValue("add");
    if (r.overLimit && !allowInputOverLimit) return;
    onChange(r.newValue, {
      type: "add",
      e: e
    });
  };
  var onInnerInputChange = function onInnerInputChange(inputValue, _ref) {
    var e = _ref.e;
    var val = formatThousandths(inputValue);
    if (!canInputNumber(val, largeNumber)) return;
    setUserInput(val);
    if (largeNumber) {
      onChange(val, {
        type: "input",
        e: e
      });
      return;
    }
    if (canSetValue(String(val), Number(tValue))) {
      var newVal = val === "" ? void 0 : Number(val);
      onChange(newVal, {
        type: "input",
        e: e
      });
    }
  };
  var handleBlur = function handleBlur(value, ctx) {
    var _props$onBlur;
    if (!props.allowInputOverLimit && value !== void 0) {
      var r = getMaxOrMinValidateResult({
        value: tValue,
        largeNumber: largeNumber,
        max: max,
        min: min
      });
      if (r === "below-minimum") {
        onChange(min, {
          type: "blur",
          e: ctx.e
        });
        return;
      }
      if (r === "exceed-maximum") {
        onChange(max, {
          type: "blur",
          e: ctx.e
        });
        return;
      }
    }
    var newValue = formatUnCompleteNumber(value, {
      decimalPlaces: decimalPlaces,
      largeNumber: largeNumber
    });
    setUserInput(getUserInput(newValue));
    if (newValue !== tValue) {
      setUserInput(tValue);
      onChange(newValue, {
        type: "blur",
        e: ctx.e
      });
    }
    (_props$onBlur = props.onBlur) === null || _props$onBlur === void 0 || _props$onBlur.call(props, newValue, ctx);
  };
  var handleFocus = function handleFocus(_, ctx) {
    var _props$onFocus;
    setUserInput(tValue);
    (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 || _props$onFocus.call(props, tValue, ctx);
  };
  var handleKeydown = function handleKeydown(value, ctx) {
    var _props$onKeydown;
    var e = ctx.e;
    var keyEvent = {
      ArrowUp: handleAdd,
      ArrowDown: handleReduce
    };
    if (keyEvent[e.key] !== void 0) {
      keyEvent[e.key](e);
    }
    (_props$onKeydown = props.onKeydown) === null || _props$onKeydown === void 0 || _props$onKeydown.call(props, value, ctx);
  };
  var handleKeyup = function handleKeyup(value, ctx) {
    var _props$onKeyup;
    (_props$onKeyup = props.onKeyup) === null || _props$onKeyup === void 0 || _props$onKeyup.call(props, value, ctx);
  };
  var handleKeypress = function handleKeypress(value, ctx) {
    var _props$onKeypress;
    (_props$onKeypress = props.onKeypress) === null || _props$onKeypress === void 0 || _props$onKeypress.call(props, value, ctx);
  };
  var handleEnter = function handleEnter(value, ctx) {
    var _props$onEnter;
    setUserInput(getUserInput(value));
    var newValue = formatUnCompleteNumber(value, {
      decimalPlaces: props.decimalPlaces,
      largeNumber: props.largeNumber
    });
    if (newValue !== value && String(newValue) !== value) {
      onChange(newValue, {
        type: "enter",
        e: ctx.e
      });
    }
    (_props$onEnter = props.onEnter) === null || _props$onEnter === void 0 || _props$onEnter.call(props, newValue, ctx);
  };
  var handleClear = function handleClear(_ref2) {
    var e = _ref2.e;
    onChange(void 0, {
      type: "clear",
      e: e
    });
    setUserInput("");
  };
  var focus = function focus() {
    inputRef.current.focus();
  };
  var blur = function blur() {
    inputRef.current.blur();
  };
  var listeners = {
    onBlur: handleBlur,
    onFocus: handleFocus,
    onKeydown: handleKeydown,
    onKeyup: handleKeyup,
    onKeypress: handleKeypress,
    onEnter: handleEnter,
    onClick: focus,
    onClear: handleClear
  };
  return {
    classPrefix: classPrefix,
    wrapClasses: wrapClasses,
    reduceClasses: reduceClasses,
    addClasses: addClasses,
    inputRef: inputRef,
    listeners: listeners,
    isError: isError,
    setIsError: setIsError,
    userInput: userInput,
    setUserInput: setUserInput,
    tValue: tValue,
    focus: focus,
    blur: blur,
    onChange: onChange,
    handleReduce: handleReduce,
    handleAdd: handleAdd,
    onInnerInputChange: onInnerInputChange
  };
}

export { useInputNumber as default, specialCode };
//# sourceMappingURL=useInputNumber.js.map
